/*
Generated from the CGMES files via cimgen: https://github.com/sogno-platform/cimgen
*/

package cim4jdb;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;

import org.springframework.data.repository.CrudRepository;

{{#class_comment}}
/**
 * {{{class_comment}}}
 */
{{/class_comment}}
@Entity
@SuppressWarnings("unused")
@Table(name = "{{table_name}}")
public class {{class_name}} extends {{subclass_of}} {

    private static final Logging LOG = Logging.getLogger({{class_name}}.class);
    private static final String CLASS_NAMESPACE = "{{class_namespace}}";

    /**
     * Default constructor.
     */
    public {{class_name}}() {
        setCimType("{{class_name}}");
    }
{{#attributes}}

    /**
{{#comment}}
     * {{comment}}
{{/comment}}
{{#is_really_used}}
{{^is_used}}
     *
     * (shouldn't have used, but is class attribute with inverse list)
{{/is_used}}
{{/is_really_used}}
{{^is_really_used}}
     *
     * NOT USED
{{#is_used}}
     * (should have used, but is list attribute)
{{/is_used}}
{{/is_really_used}}
     */
{{#is_primitive_attribute}}
    @Column(name = "{{column_name}}")
    private {{primitive_java_type}} {{variable_name}}; // {{attribute_class}}

    public {{primitive_java_type}} {{getter_name}}() {
        return {{variable_name}};
    }

    public void {{setter_name}}({{primitive_java_type}} _value_) {
        {{variable_name}} = _value_;
    }
{{^is_primitive_string}}

    public void {{setter_name}}(String _value_) {
        {{variable_name}} = get{{primitive_java_type}}FromString(_value_);
    }
{{/is_primitive_string}}

    public String {{label}}ToString() {
        return {{variable_name}} != null ? {{variable_name}}.toString() : null;
    }
{{/is_primitive_attribute}}
{{#is_datatype_attribute}}
    @Column(name = "{{column_name}}")
    private Double {{variable_name}}; // {{attribute_class}}

    public Double {{getter_name}}() {
        return {{variable_name}};
    }

    public void {{setter_name}}(Double _value_) {
        {{variable_name}} = _value_;
    }

    public void {{setter_name}}(String _value_) {
        {{variable_name}} = getDoubleFromString(_value_);
    }

    public String {{label}}ToString() {
        return {{variable_name}} != null ? {{variable_name}}.toString() : null;
    }
{{/is_datatype_attribute}}
{{#is_enum_attribute}}
    @Column(name = "{{column_name}}")
    private String {{variable_name}}; // {{attribute_class}}

    public String {{getter_name}}() {
        return {{variable_name}};
    }

    public void {{setter_name}}(String _value_) {
        {{variable_name}} = _value_;
    }

    public String {{label}}ToString() {
        return {{variable_name}};
    }
{{/is_enum_attribute}}
{{#is_class_attribute}}
    @Transient
{{#is_class_attribute_with_inverse_list}}
    private {{attribute_class}} {{variable_name}}; // ManyToOne
{{/is_class_attribute_with_inverse_list}}
{{^is_class_attribute_with_inverse_list}}
    private {{attribute_class}} {{variable_name}}; // OneToOne
{{/is_class_attribute_with_inverse_list}}
{{#is_really_used}}

    @Column(name = "{{column_name}}")
    private String {{variable_name}}Id;
{{/is_really_used}}

    public {{attribute_class}} {{getter_name}}() {
        return {{variable_name}};
    }

    public void {{setter_name}}(BaseClass _object_) {
        if (!(_object_ instanceof {{attribute_class}})) {
            throw new IllegalArgumentException("Object is not {{attribute_class}}");
        }
        if (!Objects.equals(_object_.getCimModel(), getCimModel())) {
            throw new IllegalArgumentException("Object belongs to different model");
        }
        if ({{variable_name}} != _object_) {
            {{variable_name}} = ({{attribute_class}}) _object_;
{{#inverse_setter}}
            {{variable_name}}.{{.}}(this);
{{/inverse_setter}}
{{#is_really_used}}
            {{variable_name}}Id = {{variable_name}}.getRdfid();
{{/is_really_used}}
        }
    }

{{#is_really_used}}
    public String {{label}}ToString() {
        return {{variable_name}}Id;
    }
{{/is_really_used}}
{{^is_really_used}}
    public String {{label}}ToString() {
        return {{variable_name}} != null ? {{variable_name}}.getRdfid() : null;
    }
{{/is_really_used}}
{{/is_class_attribute}}
{{#is_list_attribute}}
    @Transient
    private Set<{{attribute_class}}> {{variable_name}} = new HashSet<>(); // OneToMany

    public Set<{{attribute_class}}> {{getter_name}}() {
        return {{variable_name}};
    }

    public void {{setter_name}}(BaseClass _object_) {
        if (!(_object_ instanceof {{attribute_class}})) {
            throw new IllegalArgumentException("Object is not {{attribute_class}}");
        }
        if (!Objects.equals(_object_.getCimModel(), getCimModel())) {
            throw new IllegalArgumentException("Object belongs to different model");
        }
        if (!{{variable_name}}.contains(_object_)) {
            {{variable_name}}.add(({{attribute_class}}) _object_);
{{#inverse_setter}}
            (({{attribute_class}}) _object_).{{.}}(this);
{{/inverse_setter}}
        }
    }

    public String {{label}}ToString() {
        return getStringFromSet({{variable_name}});
    }
{{/is_list_attribute}}
{{/attributes}}

    /**
     * Nested repository. The implementation is automatically created.
     */
    public interface Repository extends CrudRepository<{{class_name}}, Long> {
    }

    /**
     * Get a list of all attribute names of the CIM type.
     *
     * The list includes all inherited attributes. The attribute name is only the
     * last part of the full name (without the class name).
     *
     * @return All attributes of the CIM type
     */
    @Override
    public List<String> getAttributeNames() {
        return ATTR_NAMES_LIST;
    }

    private static final List<String> ATTR_NAMES_LIST;
    private static final Map<String, AttrDetails> ATTR_DETAILS_MAP;
    static {
        ATTR_DETAILS_MAP = new {{class_name}}().allAttrDetailsMap();
        ATTR_NAMES_LIST = new ArrayList<>(ATTR_DETAILS_MAP.keySet());
    }

    @Override
    protected Map<String, AttrDetails> allAttrDetailsMap() {
        Map<String, AttrDetails> map = new LinkedHashMap<>(classAttrDetailsMap);
        map.putAll(super.allAttrDetailsMap());
        map.remove("LAST_ATTRIBUTE");
        return map;
    }

    @Transient
    private final Map<String, AttrDetails> classAttrDetailsMap = fillClassAttrDetailsMap();

    private Map<String, AttrDetails> fillClassAttrDetailsMap() {
        Map<String, AttrDetails> map = new LinkedHashMap<>();
{{#attributes}}
{{#is_primitive_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, true, "{{attribute_namespace}}", true, false));
{{/is_primitive_attribute}}
{{#is_datatype_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, true, "{{attribute_namespace}}", true, false));
{{/is_datatype_attribute}}
{{#is_enum_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, true, "{{attribute_namespace}}", false, true));
{{/is_enum_attribute}}
{{#is_class_attribute}}
{{#is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, true, "{{attribute_namespace}}"));
{{/is_used}}
{{^is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, false, "{{attribute_namespace}}"));
{{/is_used}}
{{/is_class_attribute}}
{{#is_list_attribute}}
{{#is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, true, "{{attribute_namespace}}"));
{{/is_used}}
{{^is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{setter_name}}, false, "{{attribute_namespace}}"));
{{/is_used}}
{{/is_list_attribute}}
{{/attributes}}
        return map;
    }

    /**
     * Get the full name of an attribute.
     *
     * The full name is "<class_name>.<attribute_name>".
     *
     * @param attrName The attribute name
     * @return         The full name
     */
    @Override
    public String getAttributeFullName(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) ? ATTR_DETAILS_MAP.get(attrName).fullName : null;
    }

    /**
     * Get an attribute value as string.
     *
     * @param attrName The attribute name
     * @return         The attribute value
     */
    @Override
    public String getAttribute(String attrName) {
        return getAttribute("{{class_name}}", attrName);
    }

    @Override
    protected String getAttribute(String className, String attrName) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var getterFunction = classAttrDetailsMap.get(attrName).getter;
            return getterFunction.get();
        }
        return super.getAttribute(className, attrName);
    }


    /**
     * Set an attribute value as object (for class and list attributes).
     *
     * @param attrName    The attribute name
     * @param objectValue The attribute value as object
     */
    @Override
    public void setAttribute(String attrName, BaseClass objectValue) {
        setAttribute("{{class_name}}", attrName, objectValue);
    }

    @Override
    protected void setAttribute(String className, String attrName, BaseClass objectValue) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var setterFunction = classAttrDetailsMap.get(attrName).objectSetter;
            setterFunction.accept(objectValue);
        } else {
            super.setAttribute(className, attrName, objectValue);
        }
    }

    /**
     * Set an attribute value as string (for primitive (including datatype) and enum attributes).
     *
     * @param attrName    The attribute name
     * @param stringValue The attribute value as string
     */
    @Override
    public void setAttribute(String attrName, String stringValue) {
        setAttribute("{{class_name}}", attrName, stringValue);
    }

    @Override
    protected void setAttribute(String className, String attrName, String stringValue) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var setterFunction = classAttrDetailsMap.get(attrName).stringSetter;
            setterFunction.accept(stringValue);
        } else {
            super.setAttribute(className, attrName, stringValue);
        }
    }

    /**
     * Check if the attribute is a primitive attribute.
     *
     * This includes datatype_attributes.
     *
     * @param attrName The attribute name
     * @return         Is it a primitive attribute?
     */
    @Override
    public boolean isPrimitiveAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isPrimitive;
    }

    /**
     * Check if the attribute is an enum attribute.
     *
     * @param attrName The attribute name
     * @return         Is it an enum attribute?
     */
    @Override
    public boolean isEnumAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isEnum;
    }

    /**
     * Check if the attribute is used.
     *
     * Some attributes are declared as unused in the CGMES definition. In most cases
     * these are list attributes, i.e. lists of links to other CIM objects. But
     * there are some exceptions, e.g. the list of ToplogicalNodes in
     * TopologicalIsland.
     *
     * @param attrName The attribute name
     * @return         Is the attribute used?
     */
    @Override
    public boolean isUsedAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isUsed;
    }

    /**
     * Get the namespace URL of an object of this class.
     *
     * @return The namespace URL
     */
    @Override
    public String getClassNamespaceUrl() {
        return CLASS_NAMESPACE;
    }

    /**
     * Get the namespace URL of an attribute (also for inherited attributes).
     *
     * @return The namespace URL
     */
    @Override
    public String getAttributeNamespaceUrl(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) ? ATTR_DETAILS_MAP.get(attrName).nameSpace : null;
    }
}
