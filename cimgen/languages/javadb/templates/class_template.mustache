/*
Generated from the CGMES files via cimgen: https://github.com/sogno-platform/cimgen
*/

package cim4jdb;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.Table;
import jakarta.persistence.Transient;

import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Setter;

import org.springframework.data.repository.CrudRepository;

{{#class_comment}}
/**
 * {{{class_comment}}}
 */
{{/class_comment}}
@Entity
@SuppressWarnings("unused")
{{#special_table_name}}
@Table(name = "{{special_table_name}}")
{{/special_table_name}}
public class {{class_name}} extends {{subclass_of}} {

    private static final Logging LOG = Logging.getLogger({{class_name}}.class);
    private static final String CLASS_NAMESPACE = "{{class_namespace}}";

    /**
     * Default constructor.
     */
    public {{class_name}}() {
        setCimType("{{class_name}}");
    }
{{#attributes}}

    /**
{{#comment}}
     * {{comment}}
{{/comment}}
{{#is_really_used}}
{{^is_used}}
     *
     * (shouldn't have used, but is class attribute with inverse list)
{{/is_used}}
{{/is_really_used}}
{{^is_really_used}}
     *
     * NOT USED
{{#is_used}}
     * (should have used, but is list attribute)
{{/is_used}}
{{/is_really_used}}
     */
{{#is_primitive_attribute}}
{{#special_column_name}}
    @Column(name = "{{special_column_name}}")
{{/special_column_name}}
{{#primitive_java_type}}
    @Getter
    @Setter
    private {{primitive_java_type}} {{> label_without_keyword}}; // {{attribute_class}}

    public String {{label}}ToString() {
        return {{> label_without_keyword}} != null ? {{> label_without_keyword}}.toString() : null;
    }

    public void {{label}}FromString(String stringValue) {
        {{> label_without_keyword}} = get{{primitive_java_type}}FromString(stringValue);
    }
{{/primitive_java_type}}
{{^primitive_java_type}}
    @Getter
    @Setter
    private {{attribute_class}} {{> label_without_keyword}};

    public String {{label}}ToString() {
        return {{> label_without_keyword}} != null ? {{> label_without_keyword}}.toString() : null;
    }

    public void {{label}}FromString(String stringValue) {
        {{> label_without_keyword}} = get{{attribute_class}}FromString(stringValue);
    }
{{/primitive_java_type}}
{{/is_primitive_attribute}}
{{#is_datatype_attribute}}
{{#special_column_name}}
    @Column(name = "{{special_column_name}}")
{{/special_column_name}}
    @Getter
    @Setter
    private Double {{label}}; // {{attribute_class}}

    public String {{label}}ToString() {
        return {{label}} != null ? {{label}}.toString() : null;
    }

    public void {{label}}FromString(String stringValue) {
        {{label}} = getDoubleFromString(stringValue);
    }
{{/is_datatype_attribute}}
{{#is_enum_attribute}}
{{#special_column_name}}
    @Column(name = "{{special_column_name}}")
{{/special_column_name}}
    @Getter
    @Setter
    private String {{label}}; // {{attribute_class}}

    public String {{label}}ToString() {
        return {{label}};
    }

    public void {{label}}FromString(String stringValue) {
        {{label}} = stringValue;
    }
{{/is_enum_attribute}}
{{#is_class_attribute}}
    @Getter
    @Transient
{{#is_class_attribute_with_inverse_list}}
    private {{attribute_class}} {{label}}; // ManyToOne
{{/is_class_attribute_with_inverse_list}}
{{^is_class_attribute_with_inverse_list}}
    private {{attribute_class}} {{label}}; // OneToOne
{{/is_class_attribute_with_inverse_list}}

    public void {{label}}FromObject(BaseClass obj) {
        if (!(obj instanceof {{attribute_class}})) {
            throw new IllegalArgumentException("Object is not {{attribute_class}}");
        }
        if ({{label}} != obj) {
            {{label}} = ({{attribute_class}}) obj;
{{#inverse_label}}
            {{label}}.{{.}}FromObject(this);
{{/inverse_label}}
{{#is_really_used}}
            {{label}}Id = {{label}}.getRdfid();
{{/is_really_used}}
        }
    }

{{#is_really_used}}
    @Getter
    private String {{label}}Id; // save to database

    public String {{label}}ToString() {
        return {{label}}Id;
    }
{{/is_really_used}}
{{^is_really_used}}
    public String {{label}}ToString() {
        return {{label}} != null ? {{label}}.getRdfid() : null;
    }
{{/is_really_used}}
{{/is_class_attribute}}
{{#is_list_attribute}}
    @Getter
    @Transient
    private Set<{{attribute_class}}> {{label}} = new HashSet<>(); // OneToMany

    public void {{label}}FromObject(BaseClass obj) {
        if (!(obj instanceof {{attribute_class}})) {
            throw new IllegalArgumentException("Object is not {{attribute_class}}");
        }
        if (!{{label}}.contains(obj)) {
            {{label}}.add(({{attribute_class}}) obj);
{{#inverse_label}}
            (({{attribute_class}}) obj).{{.}}FromObject(this);
{{/inverse_label}}
        }
    }

    public String {{label}}ToString() {
        String references = "";
        for (var obj : {{label}}) {
            references += obj.getRdfid() + " ";
        }
        return references.trim();
    }
{{/is_list_attribute}}
{{/attributes}}

    /**
     * Nested repository. The implementation is automatically created.
     */
    public interface Repository extends CrudRepository<{{class_name}}, Long> {
    }

    /**
     * Get a list of all attribute names of the CIM type.
     *
     * The list includes all inherited attributes. The attribute name is only the
     * last part of the full name (without the class name).
     *
     * @return All attributes of the CIM type
     */
    @Override
    public List<String> getAttributeNames() {
        return ATTR_NAMES_LIST;
    }

    private static final List<String> ATTR_NAMES_LIST;
    private static final Map<String, AttrDetails> ATTR_DETAILS_MAP;
    static {
        ATTR_DETAILS_MAP = new {{class_name}}().allAttrDetailsMap();
        ATTR_NAMES_LIST = new ArrayList<>(ATTR_DETAILS_MAP.keySet());
    }

    @Override
    protected Map<String, AttrDetails> allAttrDetailsMap() {
        Map<String, AttrDetails> map = new LinkedHashMap<>(classAttrDetailsMap);
        map.putAll(super.allAttrDetailsMap());
        map.remove("LAST_ATTRIBUTE");
        return map;
    }

    @Transient
    private final Map<String, AttrDetails> classAttrDetailsMap = fillClassAttrDetailsMap();

    private Map<String, AttrDetails> fillClassAttrDetailsMap() {
        Map<String, AttrDetails> map = new LinkedHashMap<>();
{{#attributes}}
{{#is_primitive_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromString, true, "{{attribute_namespace}}", true, false));
{{/is_primitive_attribute}}
{{#is_datatype_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromString, true, "{{attribute_namespace}}", true, false));
{{/is_datatype_attribute}}
{{#is_enum_attribute}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromString, true, "{{attribute_namespace}}", false, true));
{{/is_enum_attribute}}
{{#is_class_attribute}}
{{#is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromObject, true, "{{attribute_namespace}}"));
{{/is_used}}
{{^is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromObject, false, "{{attribute_namespace}}"));
{{/is_used}}
{{/is_class_attribute}}
{{#is_list_attribute}}
{{#is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromObject, true, "{{attribute_namespace}}"));
{{/is_used}}
{{^is_used}}
        map.put("{{label}}", new AttrDetails("{{class_name}}.{{label}}", this::{{label}}ToString, this::{{label}}FromObject, false, "{{attribute_namespace}}"));
{{/is_used}}
{{/is_list_attribute}}
{{/attributes}}
        return map;
    }

    /**
     * Get the full name of an attribute.
     *
     * The full name is "<class_name>.<attribute_name>".
     *
     * @param attrName The attribute name
     * @return         The full name
     */
    @Override
    public String getAttributeFullName(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) ? ATTR_DETAILS_MAP.get(attrName).fullName : null;
    }

    /**
     * Get an attribute value as string.
     *
     * @param attrName The attribute name
     * @return         The attribute value
     */
    @Override
    public String getAttribute(String attrName) {
        return getAttribute("{{class_name}}", attrName);
    }

    @Override
    protected String getAttribute(String className, String attrName) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var getterFunction = classAttrDetailsMap.get(attrName).getter;
            return getterFunction.get();
        }
        return super.getAttribute(className, attrName);
    }


    /**
     * Set an attribute value as object (for class and list attributes).
     *
     * @param attrName    The attribute name
     * @param objectValue The attribute value as object
     */
    @Override
    public void setAttribute(String attrName, BaseClass objectValue) {
        setAttribute("{{class_name}}", attrName, objectValue);
    }

    @Override
    protected void setAttribute(String className, String attrName, BaseClass objectValue) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var setterFunction = classAttrDetailsMap.get(attrName).objectSetter;
            setterFunction.accept(objectValue);
        } else {
            setAttribute(className, attrName, objectValue.getRdfid());
        }
    }

    /**
     * Set an attribute value as string (for primitive (including datatype) and enum attributes).
     *
     * @param attrName    The attribute name
     * @param stringValue The attribute value as string
     */
    @Override
    public void setAttribute(String attrName, String stringValue) {
        setAttribute("{{class_name}}", attrName, stringValue);
    }

    @Override
    protected void setAttribute(String className, String attrName, String stringValue) {
        if (classAttrDetailsMap.containsKey(attrName)) {
            var setterFunction = classAttrDetailsMap.get(attrName).stringSetter;
            setterFunction.accept(stringValue);
        } else {
            super.setAttribute(className, attrName, stringValue);
        }
    }

    /**
     * Check if the attribute is a primitive attribute.
     *
     * This includes datatype_attributes.
     *
     * @param attrName The attribute name
     * @return         Is it a primitive attribute?
     */
    @Override
    public boolean isPrimitiveAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isPrimitive;
    }

    /**
     * Check if the attribute is an enum attribute.
     *
     * @param attrName The attribute name
     * @return         Is it an enum attribute?
     */
    @Override
    public boolean isEnumAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isEnum;
    }

    /**
     * Check if the attribute is used.
     *
     * Some attributes are declared as unused in the CGMES definition. In most cases
     * these are list attributes, i.e. lists of links to other CIM objects. But
     * there are some exceptions, e.g. the list of ToplogicalNodes in
     * TopologicalIsland.
     *
     * @param attrName The attribute name
     * @return         Is the attribute used?
     */
    @Override
    public boolean isUsedAttribute(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) && ATTR_DETAILS_MAP.get(attrName).isUsed;
    }

    /**
     * Get the namespace URL of an object of this class.
     *
     * @return The namespace URL
     */
    @Override
    public String getClassNamespaceUrl() {
        return CLASS_NAMESPACE;
    }

    /**
     * Get the namespace URL of an attribute (also for inherited attributes).
     *
     * @return The namespace URL
     */
    @Override
    public String getAttributeNamespaceUrl(String attrName) {
        return ATTR_DETAILS_MAP.containsKey(attrName) ? ATTR_DETAILS_MAP.get(attrName).nameSpace : null;
    }
}
